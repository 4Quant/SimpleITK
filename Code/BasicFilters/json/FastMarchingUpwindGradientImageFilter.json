{
  "name" : "FastMarchingUpwindGradientImageFilter",
  "itk_name" : "FastMarchingUpwindGradientImageFilterBase",
  "include_files" : [
    "itkFastMarchingThresholdStoppingCriterion.h"
  ],
  "template_code_filename" : "FastMarchingImageFilter",
  "number_of_inputs" : 1,
  "template_test_filename" : "ImageFilter",
  "output_pixel_type" : "float",
  "doc" : "Docs",
  "pixel_types" : "BasicPixelIDTypeList",
  "members" : [
    {
      "name" : "NormalizationFactor",
      "type" : "double",
      "default" : "1.0",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer pixel types to represent the speed.",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : "Set/Get the Normalization Factor for the Speed Image . The values in the Speed Image is divided by this factor. This allows the use of images with integer pixel types to represent the speed."
    },
    {
      "name" : "StoppingValue",
      "type" : "double",
      "default" : "100.0",
      "custom_itk_cast" : "typedef itk::FastMarchingThresholdStoppingCriterion< InputImageType, OutputImageType > CriterionType;\ntypename CriterionType::Pointer criterion = CriterionType::New();\ncriterion->SetThreshold( m_StoppingValue );\nfilter->SetStoppingCriterion( criterion );",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set the Fast Marching algorithm Stopping Value. The Fast Marching algorithm is terminated when the value of the smallest trial point is greater than the stopping value.",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : "Get the Fast Marching algorithm Stopping Value."
    },
    {
      "name" : "TopologyCheck",
      "enum" : [
        "Nothing",
        "NoHandles",
        "Strict"
      ],
      "default" : "itk::simple::FastMarchingUpwindGradientImageFilter::Nothing",
      "doc" : "",
      "itk_type" : "typename FilterType::TopologyCheckType"
    }
  ],
  "measurements" : [
    {
      "name" : "GradientImage",
      "type" : "Image",
      "default" : "Image()",
      "custom_itk_cast" : "this->CastITKToImage(filter->GetGradientImage());",
      "briefdescriptionGet" : "",
      "no_print" : true,
      "detaileddescriptionGet" : "Get the gradient image."
    }
  ],
  "tests" : [
    {
      "tag" : "default",
      "description" : "Default parameter settings",
      "md5hash" : "b4b628f078fdfd7c14c55b1aed24e72a",
      "settings" : [
        {
          "parameter" : "TrialPoints",
          "dim" : 2,
          "value" : [
            "{70,70}",
            "{200,180}"
          ],
          "tcl_value" : [
            "70 70",
            "200 180"
          ],
          "python_value" : [
            "[70,70]",
            "[200,180]"
          ],
          "ruby_value" : [
            "[70,70]",
            "[200,180]"
          ],
          "R_value" : "list(c(70,70), c(200,180))"
        },
        {
          "parameter" : "NormalizationFactor",
          "value" : 255.0
        },
        {
          "parameter" : "StoppingValue",
          "value" : 50.0
        }
      ],
      "inputs" : [
        "Input/cthead1-Float.mha"
      ]
    }
  ],
  "briefdescription" : "Generates the upwind gradient field of fast marching arrival times.",
  "detaileddescription" : "This filter adds some extra functionality to its base class. While the solution T(x) of the Eikonal equation is being generated by the base class with the fast marching method, the filter generates the upwind gradient vectors of T(x), storing them in an image.\n\nSince the Eikonal equation generates the arrival times of a wave travelling at a given speed, the generated gradient vectors can be interpreted as the slowness (1/velocity) vectors of the front (the quantity inside the modulus operator in the Eikonal equation).\n\nGradient vectors are computed using upwind finite differences, that is, information only propagates from points where the wavefront has already passed. This is consistent with how the fast marching method works.\n\nOne more extra feature is the possibility to define a set of Target points where the propagation stops. This can be used to avoid computing the Eikonal solution for the whole domain. The front can be stopped either when one Target point is reached or all Target points are reached. The propagation can stop after a time TargetOffset has passed since the stop condition is met. This way the solution is computed a bit downstream the Target points, so that the level sets of T(x) corresponding to the Target are smooth.\n\n\\author Luca Antiga Ph.D. Biomedical Technologies Laboratory, Bioengineering Department, Mario Negri Institute, Italy."
}
